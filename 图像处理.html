<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图像处理</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 28px;
            font-weight: 600;
        }
        
        .upload-section {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: rgba(248, 249, 250, 0.8);
            border-radius: 15px;
            border: 2px dashed #ccc;
            transition: all 0.3s ease;
        }
        
        .upload-section:hover {
            border-color: #667eea;
            background: rgba(248, 249, 250, 1);
        }
        
        .upload-label {
            display: inline-block;
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .upload-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        #imageInput {
            display: none;
        }
        
        .upload-info {
            margin-top: 15px;
            color: #666;
            font-size: 14px;
        }
        
        .processing-section {
            margin-bottom: 40px;
        }
        
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
        }
        
        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            margin: 0 10px;
        }
        
        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        
        .tab-content {
            display: none;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .watermark-tools {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .tool-group {
            flex: 1;
            min-width: 200px;
        }
        
        .tool-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #333;
        }
        
        .tool-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }
        
        .tool-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .tool-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .tool-group input[type="number"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .tool-group input[type="color"] {
            width: 60px;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .button-group {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 30px 0;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #5a6268;
        }
        
        .preview-section {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        
        .image-container {
            flex: 1;
            min-width: 300px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .image-container h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        .canvas-container {
            width: 100%;
            min-height: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            transition: height 0.3s ease;
        }
        
        canvas {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }
        
        .download-section {
            text-align: center;
            margin-top: 30px;
            display: none;
        }
        
        .download-link {
            display: inline-block;
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .download-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .status-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            color: white;
            display: none;
            z-index: 1000;
        }
        
        .status-message.success {
            background: #28a745;
        }
        
        .status-message.error {
            background: #dc3545;
        }
        
        .status-message.info {
            background: #17a2b8;
        }
        
        /* 加载动画 */
        .loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            display: none;
        }
        
        .loader::after {
            content: "";
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* 响应式设计 */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 24px;
            }
            
            .button-group {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 100%;
                max-width: 300px;
            }
            
            .image-container {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>图像处理</h1>
        
        <div class="upload-section">
            <label for="imageInput" class="upload-label">
                上传图片
            </label>
            <input type="file" id="imageInput" accept="image/*">
            <p class="upload-info">支持 JPG、PNG、WEBP 等常见图片格式</p>
        </div>
        
        <div class="processing-section">
            <div class="tabs">
                <button class="tab active" data-tab="watermark">除水印</button>
                <button class="tab" data-tab="cutout">无底抠图</button>
            </div>
            
            <!-- 除水印工具 -->
            <div class="tab-content active" id="watermark-content">
                <div class="watermark-tools">
                    <div class="tool-group">
                        <label for="brushSize">画笔大小: <span id="brushSizeValue">20</span></label>
                        <input type="range" id="brushSize" min="5" max="100" value="20">
                    </div>
                    <div class="tool-group">
                        <label for="opacity">透明度: <span id="opacityValue">80</span>%</label>
                        <input type="range" id="opacity" min="10" max="100" value="80">
                    </div>
                    <div class="tool-group">
                        <label for="color">填充颜色</label>
                        <input type="color" id="color" value="#ffffff">
                    </div>
                    <div class="tool-group">
                        <label>绘制模式</label>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-secondary" id="brushModeBtn" style="flex: 1;">画笔</button>
                            <button class="btn" id="eraserModeBtn" style="flex: 1; background: #dc3545; color: white;">橡皮擦</button>
                        </div>
                    </div>
                </div>
                
                <div class="button-group">
                    <button class="btn btn-primary" id="removeWatermarkBtn">移除水印</button>
                    <button class="btn btn-secondary" id="clearCanvasBtn">清除操作</button>
                </div>
            </div>
            
            <!-- 无底抠图工具 -->
            <div class="tab-content" id="cutout-content">
                <div class="watermark-tools">
                    <div class="tool-group">
                        <label for="tolerance">容差: <span id="toleranceValue">30</span></label>
                        <input type="range" id="tolerance" min="0" max="100" value="30">
                    </div>
                    <div class="tool-group">
                        <label for="feather">羽化: <span id="featherValue">5</span></label>
                        <input type="range" id="feather" min="0" max="20" value="5">
                    </div>
                </div>
                
                <div class="button-group">
                    <button class="btn btn-primary" id="autoCutoutBtn">自动抠图</button>
                    <button class="btn btn-secondary" id="manualCutoutBtn">手动选择背景</button>
                </div>
            </div>
        </div>
        
        <div class="preview-section">
            <div class="image-container">
                <h3>原图</h3>
                <div class="canvas-container">
                    <canvas id="originalCanvas"></canvas>
                </div>
            </div>
            <div class="image-container">
                <h3>处理后</h3>
                <div class="canvas-container">
                    <canvas id="processedCanvas"></canvas>
                </div>
            </div>
        </div>
        
        <div class="download-section" id="downloadSection">
            <a href="#" class="download-link" id="downloadLink">下载处理后的图片</a>
        </div>
        
        <div class="status-message" id="statusMessage"></div>
        
        <div class="loader" id="loader"></div>
    </div>

    <script>
        // 获取DOM元素
        const imageInput = document.getElementById('imageInput');
        const originalCanvas = document.getElementById('originalCanvas');
        const processedCanvas = document.getElementById('processedCanvas');
        const originalCtx = originalCanvas.getContext('2d');
        const processedCtx = processedCanvas.getContext('2d');
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const brushSize = document.getElementById('brushSize');
        const brushSizeValue = document.getElementById('brushSizeValue');
        const opacity = document.getElementById('opacity');
        const opacityValue = document.getElementById('opacityValue');
        const colorPicker = document.getElementById('color');
        const tolerance = document.getElementById('tolerance');
        const toleranceValue = document.getElementById('toleranceValue');
        const feather = document.getElementById('feather');
        const featherValue = document.getElementById('featherValue');
        const removeWatermarkBtn = document.getElementById('removeWatermarkBtn');
        const clearCanvasBtn = document.getElementById('clearCanvasBtn');
        const autoCutoutBtn = document.getElementById('autoCutoutBtn');
        const manualCutoutBtn = document.getElementById('manualCutoutBtn');
        const downloadSection = document.getElementById('downloadSection');
        const downloadLink = document.getElementById('downloadLink');
        const statusMessage = document.getElementById('statusMessage');
        const loader = document.getElementById('loader');
        
        // 全局变量
        let currentImage = null;
        let isDrawing = false;
        let currentTab = 'watermark';
        let backgroundPoints = [];
        let isEraserMode = false; // 新增：橡皮擦模式标志
        
        // 初始化画布
        function initCanvas() {
            // 设置初始画布尺寸，但在图片加载后会被调整
            originalCanvas.width = 400;
            originalCanvas.height = 300;
            processedCanvas.width = 400;
            processedCanvas.height = 300;
            
            // 确保初始时canvas的CSS尺寸与绘图尺寸一致
            originalCanvas.style.width = '400px';
            originalCanvas.style.height = '300px';
            processedCanvas.style.width = '400px';
            processedCanvas.style.height = '300px';
            
            // 调整容器高度
            originalCanvas.parentElement.style.height = '300px';
            processedCanvas.parentElement.style.height = '300px';
            
            // 绘制占位符
            drawPlaceholder(originalCtx);
            drawPlaceholder(processedCtx);
        }
        
        // 绘制占位符
        function drawPlaceholder(ctx) {
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillStyle = '#ccc';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('请上传图片', ctx.canvas.width / 2, ctx.canvas.height / 2);
        }
        
        // 调整画布大小以适应图片 - 确保CSS显示与坐标计算一致
        function resizeCanvasToImage(canvas, image) {
            // 获取画布容器的宽度
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            
            // 设置最大宽度限制，防止页面过度拉伸
            const maxWidth = Math.min(image.width, containerWidth - 40); // 减去内边距
            const maxHeight = 600; // 设置最大高度，避免页面过长
            
            // 计算保持宽高比的缩放比例
            const ratio = Math.min(maxWidth / image.width, maxHeight / image.height);
            
            // 使用比例计算新尺寸，保持宽高比
            const newWidth = Math.floor(image.width * ratio);
            const newHeight = Math.floor(image.height * ratio);
            
            // 设置canvas的实际绘图尺寸
            canvas.width = newWidth;
            canvas.height = newHeight;
            
            // 设置高质量渲染
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingQuality = 'high';
            
            // 确保canvas元素显示尺寸与绘图尺寸一致，避免CSS缩放导致的坐标问题
            canvas.style.width = `${newWidth}px`;
            canvas.style.height = `${newHeight}px`;
            
            // 调整画布容器大小以适应新的画布尺寸
            container.style.height = `${newHeight}px`;
        }
        
        // 全局变量，用于存储原始图像的尺寸
        let originalImageWidth = 0;
        let originalImageHeight = 0;
        
        // 显示图片
        function displayImage(image) {
            // 保存原始图像尺寸
            originalImageWidth = image.width;
            originalImageHeight = image.height;
            
            // 调整画布大小
            resizeCanvasToImage(originalCanvas, image);
            resizeCanvasToImage(processedCanvas, image);
            
            // 设置高质量渲染
            originalCtx.imageSmoothingQuality = 'high';
            processedCtx.imageSmoothingQuality = 'high';
            
            // 绘制原图
            originalCtx.drawImage(image, 0, 0, originalCanvas.width, originalCanvas.height);
            
            // 复制到处理画布
            processedCtx.drawImage(image, 0, 0, processedCanvas.width, processedCanvas.height);
            
            // 保存当前图片
            currentImage = image;
            
            // 显示下载区域
            downloadSection.style.display = 'block';
            
            // 更新状态
            showStatus('图片已加载成功', 'success');
        }
        
        // 显示状态消息
        function showStatus(message, type = 'info') {
            statusMessage.textContent = message;
            statusMessage.className = 'status-message';
            statusMessage.classList.add(type);
            statusMessage.style.display = 'block';
            
            // 3秒后自动隐藏
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 3000);
        }
        
        // 显示加载动画
        function showLoader() {
            loader.style.display = 'flex';
        }
        
        // 隐藏加载动画
        function hideLoader() {
            loader.style.display = 'none';
        }
        
        // 切换标签页
        function switchTab(tabId) {
            // 更新标签状态
            tabs.forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.tab === tabId) {
                    tab.classList.add('active');
                }
            });
            
            // 更新内容状态
            tabContents.forEach(content => {
                content.classList.remove('active');
                if (content.id === tabId + '-content') {
                    content.classList.add('active');
                }
            });
            
            // 更新当前标签
            currentTab = tabId;
            
            // 如果有图片，重新显示处理后的图片
            if (currentImage) {
                processedCtx.drawImage(currentImage, 0, 0, processedCanvas.width, processedCanvas.height);
            }
        }
        
        // 初始化除水印功能
        function initWatermarkRemoval() {
            // 获取模式切换按钮
            const brushModeBtn = document.getElementById('brushModeBtn');
            const eraserModeBtn = document.getElementById('eraserModeBtn');
            
            // 画笔大小变化
            brushSize.addEventListener('input', function() {
                brushSizeValue.textContent = this.value;
            });
            
            // 透明度变化
            opacity.addEventListener('input', function() {
                opacityValue.textContent = this.value;
            });
            
            // 清除画布
            clearCanvasBtn.addEventListener('click', function() {
                if (currentImage) {
                    processedCtx.drawImage(currentImage, 0, 0, processedCanvas.width, processedCanvas.height);
                    showStatus('已清除所有操作', 'info');
                }
            });
            
            // 画笔模式按钮
            brushModeBtn.addEventListener('click', function() {
                isEraserMode = false;
                brushModeBtn.classList.add('btn-primary');
                brushModeBtn.classList.remove('btn-secondary');
                eraserModeBtn.classList.remove('btn-primary');
                eraserModeBtn.classList.add('btn-secondary');
                showStatus('已切换到画笔模式', 'info');
            });
            
            // 橡皮擦模式按钮
            eraserModeBtn.addEventListener('click', function() {
                isEraserMode = true;
                eraserModeBtn.classList.add('btn-primary');
                eraserModeBtn.classList.remove('btn-secondary');
                brushModeBtn.classList.remove('btn-primary');
                brushModeBtn.classList.add('btn-secondary');
                showStatus('已切换到橡皮擦模式', 'info');
            });
            
            // 移除水印按钮点击事件
            removeWatermarkBtn.addEventListener('click', function() {
                if (!currentImage) {
                    showStatus('请先上传图片', 'error');
                    return;
                }
                
                showLoader();
                
                // 模拟处理延迟
                setTimeout(() => {
                    try {
                        // 高级自动水印移除功能
                        const imageData = processedCtx.getImageData(0, 0, processedCanvas.width, processedCanvas.height);
                        const data = imageData.data;
                        
                        // 创建临时画布进行处理
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = processedCanvas.width;
                        tempCanvas.height = processedCanvas.height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.putImageData(imageData, 0, 0);
                        
                        // 步骤1：检测水印区域
                        // 使用多种方法组合检测：亮度分析、纹理分析、颜色分析
                        const watermarkMask = detectWatermark(tempCtx, processedCanvas.width, processedCanvas.height);
                        
                        // 步骤2：修复水印区域
                        // 使用改进的内容感知修复算法
                        repairWatermark(imageData, watermarkMask, processedCanvas.width, processedCanvas.height);
                        
                        // 将处理后的数据放回画布
                        processedCtx.putImageData(imageData, 0, 0);
                        
                        showStatus('水印移除成功', 'success');
                    } catch (error) {
                        showStatus('水印移除失败：' + error.message, 'error');
                        console.error('水印移除失败:', error);
                    }
                    
                    hideLoader();
                }, 1000);
            });
        }
        
        // 检测水印区域 - 高级算法
        function detectWatermark(ctx, width, height) {
            // 创建掩码数组
            const mask = new Uint8ClampedArray(width * height);
            
            // 获取图像数据
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // 分析每个像素
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];
                
                // 计算像素位置
                const x = (i / 4) % width;
                const y = Math.floor((i / 4) / width);
                
                // 1. 亮度分析 - 检测半透明或高亮区域
                const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                
                // 2. 纹理分析 - 检测重复模式（简单实现）
                const textureScore = analyzeTexture(data, i, width, height);
                
                // 3. 颜色分析 - 检测可能的水印颜色特征
                const colorScore = analyzeColor(r, g, b);
                
                // 综合评分判断是否为水印
                let isWatermark = false;
                
                // 文字水印通常具有以下特征：
                // - 亮度较高但不是纯白
                // - 具有一定的透明度或颜色特征
                // - 可能有重复的纹理模式
                if ((brightness > 180 && brightness < 245 && !(r > 240 && g > 240 && b > 240)) ||
                    (colorScore > 0.7 && brightness > 160) ||
                    (textureScore > 0.8 && brightness > 170)) {
                    isWatermark = true;
                }
                
                // 增强：检测常见的水印位置（角落区域）
                const cornerDistance = Math.min(
                    Math.min(x, width - x),
                    Math.min(y, height - y)
                );
                
                // 角落区域的像素更可能是水印
                if (cornerDistance < width * 0.2 && cornerDistance < height * 0.2) {
                    // 在角落区域降低判断阈值
                    if (brightness > 160 && brightness < 245) {
                        isWatermark = true;
                    }
                }
                
                // 设置掩码值
                mask[i / 4] = isWatermark ? 255 : 0;
            }
            
            // 对掩码进行形态学操作，优化水印区域
            const optimizedMask = optimizeWatermarkMask(mask, width, height);
            
            return optimizedMask;
        }
        
        // 分析像素纹理特征
        function analyzeTexture(data, index, width, height) {
            const x = (index / 4) % width;
            const y = Math.floor((index / 4) / width);
            
            // 获取周围像素的亮度
            const neighbors = [];
            const offsets = [-1, 0, 1];
            
            for (let dy of offsets) {
                for (let dx of offsets) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const neighborIndex = (ny * width + nx) * 4;
                        const r = data[neighborIndex];
                        const g = data[neighborIndex + 1];
                        const b = data[neighborIndex + 2];
                        const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                        neighbors.push(brightness);
                    }
                }
            }
            
            // 计算纹理分数（基于亮度变化）
            if (neighbors.length === 0) return 0;
            
            const avg = neighbors.reduce((a, b) => a + b, 0) / neighbors.length;
            const variance = neighbors.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / neighbors.length;
            const stdDev = Math.sqrt(variance);
            
            // 水印区域通常具有较低的纹理变化（较平滑）
            // 将标准差归一化为0-1范围的分数
            const maxStdDev = 40; // 经验值
            const textureScore = Math.max(0, Math.min(1, 1 - stdDev / maxStdDev));
            
            return textureScore;
        }
        
        // 分析颜色特征
        function analyzeColor(r, g, b) {
            // 检测常见水印颜色特征
            // 1. 轻微偏灰或偏白
            const grayDiff = Math.max(Math.abs(r - g), Math.abs(g - b), Math.abs(b - r));
            const isGrayish = grayDiff < 20;
            
            // 2. 亮度适中但不是纯白
            const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
            const isMediumBright = brightness > 170 && brightness < 245;
            
            // 3. 颜色饱和度较低
            const maxChannel = Math.max(r, g, b);
            const minChannel = Math.min(r, g, b);
            const saturation = maxChannel > 0 ? (maxChannel - minChannel) / maxChannel : 0;
            const isLowSaturation = saturation < 0.3;
            
            // 综合评分
            let score = 0;
            if (isGrayish) score += 0.4;
            if (isMediumBright) score += 0.3;
            if (isLowSaturation) score += 0.3;
            
            return score;
        }
        
        // 优化水印掩码
        function optimizeWatermarkMask(mask, width, height) {
            // 创建结果数组
            const result = new Uint8ClampedArray(mask.length);
            
            // 简单的膨胀操作，连接断开的水印区域
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = y * width + x;
                    
                    // 检查3x3邻域
                    let hasWatermark = mask[index] > 128;
                    if (!hasWatermark) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                
                                const nx = x + dx;
                                const ny = y + dy;
                                
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const neighborIndex = ny * width + nx;
                                    if (mask[neighborIndex] > 128) {
                                        hasWatermark = true;
                                        break;
                                    }
                                }
                            }
                            if (hasWatermark) break;
                        }
                    }
                    
                    result[index] = hasWatermark ? 255 : 0;
                }
            }
            
            // 应用高斯模糊平滑边缘
            const smoothedResult = applyGaussianBlur(result, width, height, 1);
            
            return smoothedResult;
        }
        
        // 修复水印区域
        function repairWatermark(imageData, mask, width, height) {
            const data = imageData.data;
            
            // 对于每个标记为水印的像素，使用改进的修复算法
            for (let i = 0; i < mask.length; i++) {
                // 只有当掩码值高于阈值时才进行修复
                if (mask[i] > 128) {
                    const pixelIndex = i * 4;
                    const x = i % width;
                    const y = Math.floor(i / width);
                    
                    // 使用更智能的内容感知修复
                    // 1. 找到周围非水印区域的像素
                    // 2. 根据距离和方向加权平均
                    const [r, g, b] = findBestReplacementColor(data, mask, x, y, width, height);
                    
                    // 应用修复后的颜色
                    data[pixelIndex] = r;
                    data[pixelIndex + 1] = g;
                    data[pixelIndex + 2] = b;
                    // 保持原有透明度
                }
            }
        }
        
        // 寻找最佳的替换颜色
        function findBestReplacementColor(data, mask, x, y, width, height) {
            let totalR = 0, totalG = 0, totalB = 0;
            let totalWeight = 0;
            
            // 搜索半径 - 从近到远寻找非水印像素
            const maxRadius = 20;
            
            for (let radius = 1; radius <= maxRadius; radius++) {
                // 按环形搜索，优先使用近处的像素
                const foundPixels = collectPixelsInRing(data, mask, x, y, width, height, radius);
                
                for (const pixel of foundPixels) {
                    // 计算距离权重（距离越近权重越大）
                    const distance = Math.sqrt(
                        Math.pow(pixel.x - x, 2) +
                        Math.pow(pixel.y - y, 2)
                    );
                    const weight = 1 / (distance + 1); // +1避免除零
                    
                    // 方向权重（优先使用相同方向的像素）
                    const dirWeight = calculateDirectionWeight(pixel.x, pixel.y, x, y, width, height, data);
                    
                    // 综合权重
                    const totalPixelWeight = weight * dirWeight;
                    
                    totalR += pixel.r * totalPixelWeight;
                    totalG += pixel.g * totalPixelWeight;
                    totalB += pixel.b * totalPixelWeight;
                    totalWeight += totalPixelWeight;
                }
                
                // 如果找到了足够的像素，就可以进行计算了
                if (totalWeight > 0 && foundPixels.length >= 4) {
                    break;
                }
            }
            
            // 如果没有找到合适的像素，使用简单的平均值
            if (totalWeight === 0) {
                const avgR = getAveragePixelColor(x * 4 * width + y * 4, 0, data);
                const avgG = getAveragePixelColor(x * 4 * width + y * 4, 1, data);
                const avgB = getAveragePixelColor(x * 4 * width + y * 4, 2, data);
                return [avgR, avgG, avgB];
            }
            
            // 计算加权平均颜色
            const r = Math.round(totalR / totalWeight);
            const g = Math.round(totalG / totalWeight);
            const b = Math.round(totalB / totalWeight);
            
            return [r, g, b];
        }
        
        // 收集环形区域内的非水印像素
        function collectPixelsInRing(data, mask, centerX, centerY, width, height, radius) {
            const pixels = [];
            
            // 计算环形的起点和终点角度
            const startAngle = 0;
            const endAngle = Math.PI * 2;
            const numPoints = Math.max(12, radius * 3); // 点数随半径增加
            
            for (let i = 0; i < numPoints; i++) {
                const angle = startAngle + (endAngle - startAngle) * i / numPoints;
                const x = Math.floor(centerX + radius * Math.cos(angle));
                const y = Math.floor(centerY + radius * Math.sin(angle));
                
                // 检查是否在画布范围内且不是水印
                if (x >= 0 && x < width && y >= 0 && y < height) {
                    const index = y * width + x;
                    if (mask[index] <= 128) { // 非水印像素
                        const pixelIndex = index * 4;
                        pixels.push({
                            x: x,
                            y: y,
                            r: data[pixelIndex],
                            g: data[pixelIndex + 1],
                            b: data[pixelIndex + 2]
                        });
                    }
                }
            }
            
            return pixels;
        }
        
        // 计算方向权重
        function calculateDirectionWeight(sampleX, sampleY, targetX, targetY, width, height, data) {
            // 简单的实现：分析该方向上的颜色一致性
            const dx = sampleX - targetX;
            const dy = sampleY - targetY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance === 0) return 1;
            
            const stepX = dx / distance;
            const stepY = dy / distance;
            
            let consistentCount = 0;
            const maxSteps = Math.min(5, Math.floor(distance / 2));
            
            // 检查从采样点向远离目标点方向的颜色一致性
            let currentX = sampleX;
            let currentY = sampleY;
            
            for (let i = 0; i < maxSteps; i++) {
                currentX += stepX;
                currentY += stepY;
                
                if (currentX < 0 || currentX >= width || currentY < 0 || currentY >= height) {
                    break;
                }
                
                const index1 = Math.floor(currentY) * width + Math.floor(currentX);
                const index2 = Math.floor(sampleY) * width + Math.floor(sampleX);
                
                const pixelIndex1 = index1 * 4;
                const pixelIndex2 = index2 * 4;
                
                const r1 = data[pixelIndex1];
                const g1 = data[pixelIndex1 + 1];
                const b1 = data[pixelIndex1 + 2];
                
                const r2 = data[pixelIndex2];
                const g2 = data[pixelIndex2 + 1];
                const b2 = data[pixelIndex2 + 2];
                
                // 计算颜色差异
                const colorDiff = Math.sqrt(
                    Math.pow(r1 - r2, 2) +
                    Math.pow(g1 - g2, 2) +
                    Math.pow(b1 - b2, 2)
                );
                
                if (colorDiff < 30) { // 颜色差异较小
                    consistentCount++;
                }
            }
            
            // 归一化权重
            const weight = (consistentCount + 1) / (maxSteps + 1);
            
            return weight;
        }
        
        // 设置绘制事件 - 简化设置，直接绑定函数
        processedCanvas.addEventListener('mousedown', startDrawing);
        processedCanvas.addEventListener('mousemove', draw);
        
        processedCanvas.addEventListener('mouseup', stopDrawing);
        processedCanvas.addEventListener('mouseout', stopDrawing);
        
        // 移动端触摸支持
        processedCanvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            startDrawing(e); // 直接传递事件对象，让draw函数内部处理
        });
        
        processedCanvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
            draw(e); // 直接传递事件对象，让draw函数内部处理
        });
        
        processedCanvas.addEventListener('touchend', stopDrawing);
        
        // 获取周围像素的平均颜色（辅助函数）
        function getAveragePixelColor(index, colorChannel, data) {
            const canvasWidth = processedCanvas.width;
            const pixelX = (index / 4) % canvasWidth;
            const pixelY = Math.floor((index / 4) / canvasWidth);
            
            let sum = 0;
            let count = 0;
            
            // 检查周围8个像素
            const offsets = [-1, 0, 1];
            
            for (let dx of offsets) {
                for (let dy of offsets) {
                    if (dx === 0 && dy === 0) continue; // 跳过当前像素
                    
                    const newX = pixelX + dx;
                    const newY = pixelY + dy;
                    
                    // 确保在画布范围内
                    if (newX >= 0 && newX < canvasWidth && newY >= 0 && newY < processedCanvas.height) {
                        const newIndex = (newY * canvasWidth + newX) * 4 + colorChannel;
                        sum += data[newIndex];
                        count++;
                    }
                }
            }
            
            return count > 0 ? Math.floor(sum / count) : data[index + colorChannel];
        }
        
        // 开始绘制
        function startDrawing(e) {
            if (!currentImage || currentTab !== 'watermark') return;
            
            isDrawing = true;
            
            // 直接调用draw函数，让它使用统一的坐标计算逻辑
            draw(e);
        }
        
        // 绘制
        function draw(e) {
            if (!isDrawing || !currentImage || currentTab !== 'watermark') return;
            
            // 获取画布的矩形信息，用于精确计算坐标
            const rect = processedCanvas.getBoundingClientRect();
            
            // 计算canvas元素的缩放比例（实际显示尺寸与绘图缓冲区尺寸的比率）
            const scaleX = processedCanvas.width / rect.width;
            const scaleY = processedCanvas.height / rect.height;
            
            // 统一的坐标计算方法，适用于所有事件类型
            // 计算鼠标/触摸位置相对于画布左上角的精确坐标，并考虑缩放比例
            let x, y;
            if (e.type.includes('mouse')) {
                // 鼠标事件：使用clientX/Y计算相对于画布的坐标，并根据缩放比例调整
                x = (e.clientX - rect.left) * scaleX;
                y = (e.clientY - rect.top) * scaleY;
            } else if (e.type.includes('touch')) {
                // 触摸事件：获取第一个触摸点并计算相对于画布的坐标，并根据缩放比例调整
                const touch = e.touches[0];
                x = (touch.clientX - rect.left) * scaleX;
                y = (touch.clientY - rect.top) * scaleY;
            } else {
                // 最后的安全检查
                console.error('无法识别的事件类型');
                return;
            }
            
            // 获取当前画笔大小
            const brushRadius = parseInt(brushSize.value);
            
            // 设置绘制参数
            processedCtx.globalAlpha = opacity.value / 100;
            
            if (isEraserMode) {
                // 橡皮擦模式：使用destination-out合成模式，可以显示擦除区域
                processedCtx.globalCompositeOperation = 'destination-out';
                processedCtx.fillStyle = 'rgba(0, 0, 0, 1)'; // 擦除颜色不影响效果，但需要设置
                
                // 优化橡皮擦光标，确保与实际擦除区域完全匹配
                const cursorSize = brushRadius * 2;
                processedCanvas.style.cursor = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${cursorSize}' height='${cursorSize}' viewBox='0 0 ${cursorSize} ${cursorSize}'%3E%3Ccircle cx='${brushRadius}' cy='${brushRadius}' r='${brushRadius}' fill='none' stroke='rgba(255,0,0,0.7)' stroke-width='1.5'/%3E%3C/svg%3E") ${brushRadius} ${brushRadius}, auto`;
            } else {
                // 画笔模式：使用正常合成模式
                processedCtx.globalCompositeOperation = 'source-over';
                processedCtx.fillStyle = colorPicker.value || '#ffffff';
                // 设置画笔鼠标样式
                processedCanvas.style.cursor = 'crosshair';
            }
            
            // 坐标安全检查，确保在画布范围内
            const safeX = Math.max(0, Math.min(x, processedCanvas.width));
            const safeY = Math.max(0, Math.min(y, processedCanvas.height));
            
            // 绘制圆形笔触，确保与光标显示完全一致
            processedCtx.beginPath();
            processedCtx.arc(safeX, safeY, brushRadius, 0, Math.PI * 2);
            processedCtx.fill();
            
            // 重置透明度，但保留合成模式直到下一次绘制
            processedCtx.globalAlpha = 1;
        }
        
        // 停止绘制
        function stopDrawing() {
            isDrawing = false;
            // 确保重置合成模式
            processedCtx.globalCompositeOperation = 'source-over';
        }
        
        // 初始化抠图功能
        function initCutout() {
            // 容差变化
            tolerance.addEventListener('input', function() {
                toleranceValue.textContent = this.value;
            });
            
            // 羽化变化
            feather.addEventListener('input', function() {
                featherValue.textContent = this.value;
            });
            
            // 自动抠图
            autoCutoutBtn.addEventListener('click', function() {
                if (!currentImage) {
                    showStatus('请先上传图片', 'error');
                    return;
                }
                
                showLoader();
                
                // 模拟处理延迟
                setTimeout(() => {
                    autoRemoveBackground();
                    hideLoader();
                }, 500);
            });
            
            // 手动选择背景颜色
            manualCutoutBtn.addEventListener('click', function() {
                colorPicker.click();
            });
            
            // 颜色选择变化
            colorPicker.addEventListener('change', function() {
                if (!currentImage) {
                    showStatus('请先上传图片', 'error');
                    return;
                }
                
                showLoader();
                
                // 模拟处理延迟
                setTimeout(() => {
                    removeBackgroundByColor(this.value);
                    hideLoader();
                }, 500);
            });
        }
        
        // 改进的自动移除背景
        function autoRemoveBackground() {
            try {
                // 检查是否有图片
                if (!currentImage) {
                    showStatus('请先上传图片', 'error');
                    return;
                }
                
                // 获取图像数据
                const imageData = processedCtx.getImageData(0, 0, processedCanvas.width, processedCanvas.height);
                const data = imageData.data;
                const threshold = parseInt(tolerance.value || 30);
                const featherAmount = parseInt(feather.value || 5);
                
                // 增强的背景色采样 - 采样四个角落和中心区域
                let bgR = 0, bgG = 0, bgB = 0;
                let count = 0;
                const sampleSize = Math.min(15, Math.floor(processedCanvas.width / 10), Math.floor(processedCanvas.height / 10));
                
                // 采样四个角落
                // 左上角
                for (let y = 0; y < Math.min(sampleSize, processedCanvas.height); y++) {
                    for (let x = 0; x < Math.min(sampleSize, processedCanvas.width); x++) {
                        const index = (y * processedCanvas.width + x) * 4;
                        bgR += data[index];
                        bgG += data[index + 1];
                        bgB += data[index + 2];
                        count++;
                    }
                }
                
                // 右上角
                for (let y = 0; y < Math.min(sampleSize, processedCanvas.height); y++) {
                    for (let x = processedCanvas.width - sampleSize; x < processedCanvas.width; x++) {
                        const index = (y * processedCanvas.width + x) * 4;
                        bgR += data[index];
                        bgG += data[index + 1];
                        bgB += data[index + 2];
                        count++;
                    }
                }
                
                // 左下角
                for (let y = processedCanvas.height - sampleSize; y < processedCanvas.height; y++) {
                    for (let x = 0; x < Math.min(sampleSize, processedCanvas.width); x++) {
                        const index = (y * processedCanvas.width + x) * 4;
                        bgR += data[index];
                        bgG += data[index + 1];
                        bgB += data[index + 2];
                        count++;
                    }
                }
                
                // 右下角
                for (let y = processedCanvas.height - sampleSize; y < processedCanvas.height; y++) {
                    for (let x = processedCanvas.width - sampleSize; x < processedCanvas.width; x++) {
                        const index = (y * processedCanvas.width + x) * 4;
                        bgR += data[index];
                        bgG += data[index + 1];
                        bgB += data[index + 2];
                        count++;
                    }
                }
                
                // 中心区域
                const centerX = Math.floor(processedCanvas.width / 2);
                const centerY = Math.floor(processedCanvas.height / 2);
                for (let y = Math.max(0, centerY - sampleSize/2); y < Math.min(processedCanvas.height, centerY + sampleSize/2); y++) {
                    for (let x = Math.max(0, centerX - sampleSize/2); x < Math.min(processedCanvas.width, centerX + sampleSize/2); x++) {
                        const index = (y * processedCanvas.width + x) * 4;
                        bgR += data[index];
                        bgG += data[index + 1];
                        bgB += data[index + 2];
                        count++;
                    }
                }
                
                if (count > 0) {
                    bgR = Math.round(bgR / count);
                    bgG = Math.round(bgG / count);
                    bgB = Math.round(bgB / count);
                } else {
                    throw new Error('无法获取背景色样本');
                }
                
                // 创建临时画布
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = processedCanvas.width;
                tempCanvas.height = processedCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // 先绘制原图到临时画布
                tempCtx.drawImage(processedCanvas, 0, 0);
                
                // 创建掩码图像数据
                const maskImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const maskData = maskImageData.data;
                
                // 根据颜色相似度创建初步掩码
                const initialMask = new Uint8ClampedArray(data.length / 4); // 存储0-255的alpha值
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // 计算颜色距离，增强版：考虑色彩空间和亮度差异
                    const colorDistance = Math.sqrt(
                        Math.pow(r - bgR, 2) * 0.3 +
                        Math.pow(g - bgG, 2) * 0.59 +
                        Math.pow(b - bgB, 2) * 0.11
                    );
                    
                    // 计算亮度差异
                    const brightnessImg = (r * 0.299 + g * 0.587 + b * 0.114);
                    const brightnessBg = (bgR * 0.299 + bgG * 0.587 + bgB * 0.114);
                    const brightnessDiff = Math.abs(brightnessImg - brightnessBg);
                    
                    // 组合颜色距离和亮度差异，更准确地判断背景
                    const combinedDistance = colorDistance * 0.7 + brightnessDiff * 0.3;
                    
                    // 根据组合距离设置透明度
                    if (combinedDistance < threshold - featherAmount) {
                        initialMask[i / 4] = 0; // 完全透明（背景）
                    } else if (combinedDistance < threshold + featherAmount) {
                        // 羽化过渡
                        const alpha = ((combinedDistance - (threshold - featherAmount)) / (featherAmount * 2)) * 255;
                        initialMask[i / 4] = alpha;
                    } else {
                        initialMask[i / 4] = 255; // 不透明（前景）
                    }
                }
                
                // 应用高斯模糊优化边缘（简单实现）
                const smoothedMask = applyGaussianBlur(initialMask, processedCanvas.width, processedCanvas.height, 1);
                
                // 将优化后的掩码应用到图像数据
                for (let i = 0; i < data.length; i += 4) {
                    maskData[i + 3] = smoothedMask[i / 4];
                }
                
                // 清除临时画布并设置透明背景
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                // 应用处理后的掩码
                tempCtx.putImageData(maskImageData, 0, 0);
                
                // 清除处理画布并设置透明背景
                processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
                // 将带有透明背景的结果绘制到处理画布
                processedCtx.drawImage(tempCanvas, 0, 0);
                
                showStatus('自动抠图完成', 'success');
            } catch (error) {
                showStatus('自动抠图失败：' + error.message, 'error');
                console.error('自动抠图失败:', error);
            }
        }
        
        // 应用简单的高斯模糊到掩码（优化边缘）
        function applyGaussianBlur(mask, width, height, radius) {
            const result = new Uint8ClampedArray(mask.length);
            const kernel = [1, 2, 1]; // 简单的高斯核
            const kernelSize = kernel.length;
            const kernelSum = kernel.reduce((a, b) => a + b, 0);
            
            // 水平方向模糊
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let sum = 0;
                    for (let k = 0; k < kernelSize; k++) {
                        const nx = Math.max(0, Math.min(width - 1, x + k - Math.floor(kernelSize / 2)));
                        const index = y * width + nx;
                        sum += mask[index] * kernel[k];
                    }
                    result[y * width + x] = Math.min(255, Math.max(0, Math.round(sum / kernelSum)));
                }
            }
            
            // 垂直方向模糊
            const temp = new Uint8ClampedArray(result);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let sum = 0;
                    for (let k = 0; k < kernelSize; k++) {
                        const ny = Math.max(0, Math.min(height - 1, y + k - Math.floor(kernelSize / 2)));
                        const index = ny * width + x;
                        sum += temp[index] * kernel[k];
                    }
                    result[y * width + x] = Math.min(255, Math.max(0, Math.round(sum / kernelSum)));
                }
            }
            
            return result;
        }
        
        // 根据指定颜色移除背景
        function removeBackgroundByColor(targetColor) {
            try {
                // 检查是否有图片
                if (!currentImage) {
                    showStatus('请先上传图片', 'error');
                    return;
                }
                
                // 获取图像数据
                const imageData = processedCtx.getImageData(0, 0, processedCanvas.width, processedCanvas.height);
                const data = imageData.data;
                const threshold = parseInt(tolerance.value || 30);
                const featherAmount = parseInt(feather.value || 5);
                
                // 解析颜色值
                let bgR, bgG, bgB;
                
                if (typeof targetColor === 'string') {
                    // 处理十六进制颜色
                    if (targetColor.startsWith('#')) {
                        const hex = targetColor.replace('#', '');
                        bgR = parseInt(hex.substring(0, 2), 16);
                        bgG = parseInt(hex.substring(2, 4), 16);
                        bgB = parseInt(hex.substring(4, 6), 16);
                    } 
                    // 处理RGB颜色
                    else if (targetColor.startsWith('rgb')) {
                        const match = targetColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                        if (match) {
                            bgR = parseInt(match[1]);
                            bgG = parseInt(match[2]);
                            bgB = parseInt(match[3]);
                        } else {
                            throw new Error('无效的RGB颜色格式');
                        }
                    } else {
                        throw new Error('不支持的颜色格式');
                    }
                } 
                // 处理颜色数组
                else if (Array.isArray(targetColor) && targetColor.length >= 3) {
                    bgR = Math.floor(targetColor[0]);
                    bgG = Math.floor(targetColor[1]);
                    bgB = Math.floor(targetColor[2]);
                } else {
                    throw new Error('无效的颜色数据');
                }
                
                // 验证颜色值范围
                if (isNaN(bgR) || isNaN(bgG) || isNaN(bgB) || 
                    bgR < 0 || bgR > 255 || 
                    bgG < 0 || bgG > 255 || 
                    bgB < 0 || bgB > 255) {
                    throw new Error('颜色值必须在0-255范围内');
                }
                
                // 创建临时画布
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = processedCanvas.width;
                tempCanvas.height = processedCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // 先绘制原图到临时画布
                tempCtx.drawImage(processedCanvas, 0, 0);
                
                // 获取掩码图像数据
                const maskImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const maskData = maskImageData.data;
                
                // 根据颜色相似度创建掩码
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // 计算颜色距离
                    const distance = Math.sqrt(
                        Math.pow(r - bgR, 2) +
                        Math.pow(g - bgG, 2) +
                        Math.pow(b - bgB, 2)
                    );
                    
                    // 根据距离设置透明度
                    if (distance < threshold - featherAmount) {
                        maskData[i + 3] = 0; // 完全透明（背景）
                    } else if (distance < threshold + featherAmount) {
                        // 羽化过渡
                        const alpha = ((distance - (threshold - featherAmount)) / (featherAmount * 2)) * 255;
                        maskData[i + 3] = alpha;
                    }
                    // 否则保持不透明（前景）
                }
                
                // 清除临时画布并设置透明背景
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                // 应用处理后的掩码
                tempCtx.putImageData(maskImageData, 0, 0);
                
                // 清除处理画布并设置透明背景
                processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
                // 将带有透明背景的结果绘制到处理画布
                processedCtx.drawImage(tempCanvas, 0, 0);
                
                showStatus('手动抠图完成', 'success');
            } catch (error) {
                showStatus('手动抠图失败：' + error.message, 'error');
                console.error('手动抠图失败:', error);
            }
        }
        
        // 创建高清输出画布的函数
        function createHighResolutionCanvas() {
            // 检查是否有图片
            if (!currentImage) {
                throw new Error('没有可处理的图片');
            }
            
            // 创建一个新的高清画布
            const highResCanvas = document.createElement('canvas');
            
            // 获取原始图像尺寸
            let targetWidth = originalImageWidth || currentImage.width;
            let targetHeight = originalImageHeight || currentImage.height;
            
            // 设置最大尺寸限制，避免处理超大图像时可能出现的性能问题
            const MAX_DIMENSION = 5000; // 最大宽度或高度
            
            // 如果图像尺寸超过最大限制，按比例缩小
            if (targetWidth > MAX_DIMENSION || targetHeight > MAX_DIMENSION) {
                const ratio = MAX_DIMENSION / Math.max(targetWidth, targetHeight);
                targetWidth = Math.floor(targetWidth * ratio);
                targetHeight = Math.floor(targetHeight * ratio);
            }
            
            // 设置高清画布尺寸
            highResCanvas.width = targetWidth;
            highResCanvas.height = targetHeight;
            
            const highResCtx = highResCanvas.getContext('2d');
            
            // 为了保持图像锐利度，禁用图像平滑处理
            highResCtx.imageSmoothingEnabled = false;
            
            // 1. 创建透明背景的高清画布
            highResCtx.fillStyle = 'rgba(0, 0, 0, 0)';
            highResCtx.fillRect(0, 0, targetWidth, targetHeight);
            
            // 2. 绘制原始高清图像到高清画布上
            highResCtx.drawImage(
                currentImage, 
                0, 0, currentImage.width, currentImage.height, 
                0, 0, targetWidth, targetHeight
            );
            
            // 3. 创建一个与高清尺寸匹配的处理画布副本
            const scaledProcessedCanvas = document.createElement('canvas');
            scaledProcessedCanvas.width = targetWidth;
            scaledProcessedCanvas.height = targetHeight;
            const scaledProcessedCtx = scaledProcessedCanvas.getContext('2d');
            
            // 禁用平滑处理以保持处理细节
            scaledProcessedCtx.imageSmoothingEnabled = false;
            
            // 将处理画布缩放到高清尺寸
            scaledProcessedCtx.drawImage(
                processedCanvas, 
                0, 0, processedCanvas.width, processedCanvas.height, 
                0, 0, targetWidth, targetHeight
            );
            
            // 4. 创建一个遮罩画布，用于提取处理画布中的透明区域
            const maskCanvas = document.createElement('canvas');
            maskCanvas.width = targetWidth;
            maskCanvas.height = targetHeight;
            const maskCtx = maskCanvas.getContext('2d');
            
            // 禁用平滑处理
            maskCtx.imageSmoothingEnabled = false;
            
            // 复制处理画布到遮罩画布
            maskCtx.drawImage(scaledProcessedCanvas, 0, 0);
            
            // 5. 将遮罩应用到高清画布上
            // 设置合成模式为"destination-in"，只保留高清画布中与遮罩重叠的不透明部分
            highResCtx.globalCompositeOperation = 'destination-in';
            highResCtx.drawImage(maskCanvas, 0, 0);
            
            // 6. 重置合成模式
            highResCtx.globalCompositeOperation = 'source-over';
            
            // 7. 使用"source-atop"模式绘制处理画布内容，保留细节
            highResCtx.globalCompositeOperation = 'source-atop';
            highResCtx.drawImage(scaledProcessedCanvas, 0, 0);
            
            // 8. 最后使用"source-over"模式确保所有内容都正确绘制
            highResCtx.globalCompositeOperation = 'source-over';
            
            return highResCanvas;
        }
        
        // 设置下载功能
        function setupDownload() {
            // 标准下载
            downloadLink.addEventListener('click', function(e) {
                e.preventDefault();
                
                if (!currentImage) {
                    showStatus('没有可下载的图片', 'error');
                    return;
                }
                
                // 将Canvas内容转换为图片URL
                const dataURL = processedCanvas.toDataURL('image/png');
                
                // 创建临时链接进行下载
                const tempLink = document.createElement('a');
                tempLink.href = dataURL;
                tempLink.download = 'processed_image_' + new Date().getTime() + '.png';
                tempLink.style.display = 'none';
                document.body.appendChild(tempLink);
                
                // 触发下载
                tempLink.click();
                
                // 清理临时链接
                document.body.removeChild(tempLink);
                
                showStatus('图片下载成功', 'success');
            });
            
            // 查找或创建高清下载按钮
            let highResDownloadBtn = document.getElementById('highResDownloadBtn');
            if (!highResDownloadBtn) {
                // 如果不存在，创建高清下载按钮
                highResDownloadBtn = document.createElement('button');
                highResDownloadBtn.id = 'highResDownloadBtn';
                highResDownloadBtn.className = 'btn btn-secondary';
                highResDownloadBtn.textContent = '下载高清图像';
                
                // 添加到下载区域
                const downloadArea = downloadLink.parentElement;
                downloadArea.appendChild(highResDownloadBtn);
            }
            
            // 添加高清下载点击事件
            highResDownloadBtn.addEventListener('click', function(e) {
                e.preventDefault();
                
                try {
                    showLoader();
                    
                    // 使用setTimeout让加载动画显示
                    setTimeout(() => {
                        try {
                            // 创建高清画布
                            const highResCanvas = createHighResolutionCanvas();
                            
                            // 生成高清图片URL，使用最高质量设置
                            const dataURL = highResCanvas.toDataURL('image/png', 1.0);
                            
                            // 创建临时链接进行下载
                            const tempLink = document.createElement('a');
                            tempLink.href = dataURL;
                            tempLink.download = 'processed_image_highres_' + new Date().getTime() + '.png';
                            tempLink.style.display = 'none';
                            document.body.appendChild(tempLink);
                            
                            // 触发下载
                            tempLink.click();
                            
                            // 清理临时链接
                            document.body.removeChild(tempLink);
                            
                            showStatus('高清图片下载成功', 'success');
                        } catch (error) {
                            showStatus('高清图片下载失败：' + error.message, 'error');
                            console.error('高清图片下载失败:', error);
                        } finally {
                            hideLoader();
                        }
                    }, 300);
                } catch (error) {
                    showStatus('高清图片下载失败：' + error.message, 'error');
                    console.error('高清图片下载失败:', error);
                }
            });
        }
        
        // 初始化事件监听
        function initEventListeners() {
            // 图片上传
            imageInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                // 检查文件类型
                if (!file.type.match('image.*')) {
                    showStatus('请上传有效的图片文件', 'error');
                    return;
                }
                
                const reader = new FileReader();
                
                reader.onload = function(event) {
                    const img = new Image();
                    
                    img.onload = function() {
                        displayImage(img);
                    };
                    
                    img.onerror = function() {
                        showStatus('图片加载失败', 'error');
                    };
                    
                    img.src = event.target.result;
                };
                
                reader.readAsDataURL(file);
            });
            
            // 标签切换
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    switchTab(this.dataset.tab);
                });
            });
        }
        
        // 初始化应用
        function initApp() {
            initCanvas();
            initEventListeners();
            initWatermarkRemoval();
            initCutout();
            setupDownload();
        }
        
        // 启动应用
        window.addEventListener('load', initApp);
    </script>
</body>
</html>